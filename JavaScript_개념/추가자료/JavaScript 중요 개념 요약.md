# 자바스크립트 중요 개념 요약

### 1. 자바스크립트란

자바스크립트는 인터프리터 언어로, 클라이언트 측에서 실행되어 웹 페이지의 동작을 제어하고, 사용자와 상호작용하는 기능을 제공합니다.

뿐만 아니라 Node.js와 같은 환경을 통해 서버 측에서도 동작하며, 데이터베이스 관리, 모바일 앱 개발, 데스크톱 앱 개발 등에도 사용됩니다.

따라서, 자바스크립트는 웹 개발뿐만 아니라 다양한 분야에서 활용되는 범용 프로그래밍 언어라고 할 수 있습니다.

</br>

### 2. var, let, const의 차이점

`var`는 함수형 스코프에 속하며, 재선언과 재할당이 가능합니다. 따라서 호이스팅 가능하며, 이로 인해 예측하지 못한 결과를 가져올 수 있기 때문에 현재는 잘 쓰이지 않는 변수 선언 방식입니다.

`let`은 블록 스코프에 속하며, 재선언은 불가능하지만 재할당은 가능합니다. 호이스팅되지만, 선언된 변수는 초기화되기 전까지 `TDZ(Temporal Dead Zone)`에 속하게 됩니다. 따라서, 선언은 이루어졌지만 아직 초기화되지 않은 상태에서 변수를 참조하려고 하면 오류가 발생합니다. 이로 인해 실제로는 호이스팅이 이루어진 것처럼 보이지 않습니다.

`const`는 블록 스코프에 속하며, 재선언과 재할당 모두 불가능합니다. 선언 시 선언과 할당을 동시에 해야합니다. 호이스팅되지만, 선언된 변수는 초기화되기 전까지 `TDZ(Temporal Dead Zone)`에 속하게 됩니다. 따라서, 선언은 이루어졌지만 아직 초기화되지 않은 상태에서 변수를 참조하려고 하면 오류가 발생합니다. 이로 인해 실제로는 호이스팅이 이루어진 것처럼 보이지 않습니다.

</br>

### 3. 스코프

`스코프`란 변수의 유효범위 변수가 접근할 수 있는 범위를 의미합니다.

`스코프`에 종류에는 `전역 스코프`와 `지역 스코프`가 있으며, `전역 스코프`는 전역에서 변수의 접근이 가능한 스코프이며, 지역 스코프는특정 블록내 접근 가능한 스코프를 의미합니다.

`지역 스코프`는 `함수 스코프`와`블록 스코프`로 나뉘며, `함수 스코프`는 함수 내부에서만 접근이 가능한 스코프 이며, `블록 스코프`는 블록 내부에서만 접근 가능한 스코프를 의미합니다.

</br>

### 4. 호이스팅과 TDZ

`호이스팅`이란 자바스크립트에서 함수나 변수가 최상위로 끌어 올려간 것처럼 동작하는 현상을 의미합니다.

`TDZ`란 일시적 사각지대로 변수가 선언된 위치에서 초기화되기 전까지의 영역을 의미합니다. 선언 전에 변수에 접근하는 것을 금지 시키는 역할을 합니다.

</br>

### 5. 자바스크립트의 데이터의 종류

자바스크립트의 데이터 타입의 종류로는 원시타입과 참조타입으로 나뉩니다.

원시타입의 경우 `number`, `string`, `boolean`, `undefined`, `null`, `NaN,` `symbol` 등이 있습니다.

참조타입의 경우 `array`, `object`, `date`, `정규표현식`, `function` 등이 있습니다.

원시타입은 불변성을 가지며, 값 자체가 메모리에 저장되며, 이 값은 변경할 수 없습니다. 반면 참조타입은 불변성을 갖지 않으며, 값이 저장된 메모리의 주소를 참조하기 때문에 값이 변경될 수 있습니다. 따라서 참조타입의 변수를 다른 변수에 할당할 경우, 같은 메모리 주소를 참조하게 되므로 한 변수에서 값을 변경하면 다른 변수에서도 그 변경이 반영됩니다.

</br>

### 6. 실행 컨텍스트

`실행 컨텍스트`란 코드에 제공할 `환경정보`들을 모아놓은 객체입니다.

`환경정보`는 `변수 환경`, `렉시컬 환경`, `this 바인딩`으로 이루어져 있습니다.

자바스크립트는 실행 전 실행 컨텍스트에 필요한 환경정보들을 모아 컨텍스트를 구성하고 이를 콜 스텍에 쌓아 놓았다가 가장 위에 쌓여 있는 컨텍스트와 관련 있는 코드들을 실행하여 전체 코드의 환경과 순서들 보장합니다.

실행 컨텍스트는 `글로벌 컨텍스트`와 `함수 컨텍스트`로 나뉩니다.

`글로벌 컨텍스트`는 전역 코드(즉, 어떤 함수 안에도 속하지 않은 코드)를 위한 실행 컨텍스트입니다. 이는 전역 변수, 전역 함수, 전역 객체(window 또는 global), this 등을 포함합니다.

`함수 컨텍스트`는 함수가 호출될 때마다 새로운 함수 컨텍스트가 생성되며, 각 함수 컨텍스트는 자신만의 변수 환경, 렉시컬 환경, this 바인딩을 가집니다. 함수 컨텍스트는 함수 종료시 제거됩니다.

</br>

### 7. 이벤트 루프와 태스크 큐

자바스크립트는 싱글 스레드 언어로, 한 번에 하나의 작업만 처리할 수 있습니다. 그러나 비동기 방식을 통해 동시성을 지원하며, 이를 가능하게 하는 것이 바로 이벤트 루프와 태스크 큐입니다.

`이벤트 루프`는 콜 스택과 태스크 큐를 관찰하며, 콜 스택이 비어 있을 때 태스크 큐에 있는 작업을 콜 스택으로 이동시킵니다.

`태스크 큐`는 비동기 작업이 완료되면 그 결과를 태스크 큐에 넣습니다. 이벤트 루프는 콜 스택이 비어 있을 때 태스크 큐에서 가장 오래된 작업을 가져와 콜 스택으로 옮깁니다.

</br>

### 8. 클로저

함수와 그 함수가 선언될 당시의 렉시컬 환경과의 조합입니다. 즉, 함수가 생성될 당시의 스코프에 있는 모든 변수를 기억하고, 이후에도 계속 접근할 수 있는 특성을 말합니다.

클로저를 이용하면 특정 함수에서만 사용되는 'private' 변수를 만들 수 있습니다. 이는 외부에서 직접 접근할 수 없는 변수를 만들어 데이터를 보호하는 데 사용됩니다.

그러나 클로저는 외부 함수의 변수를 참조하고 있기 때문에, 이 변수는 가비지 컬렉션의 대상이 되지 않습니다. 따라서 메모리 누수 현상이 발생할 수 있으며, 클로저는 사용 후 null로 설정하여 참조를 제거 하는것이 좋습니다.

</br>

### 9. 자바스크립트의 동기와 비동기

`동기 처리`는 코드가 순차적으로 실행되는 것을 의미합니다. 한 작업이 완료될 때까지 다음 작업은 대기해야 합니다. 즉, 어떤 작업이 끝나는 것을 기다린 후에 다음 작업을 실행합니다.

`비동기 처리`는 특정 작업의 완료를 기다리지 않고 다음 작업을 바로 실행하는 것을 의미합니다.

자바스크립트는 싱글 스레드이지만, `이벤트 루프와 태스크 큐`, `web API` 등을 통해 비동기를 처리할 수 있브니다.

</br>

### 10. 콜백 함수

`콜백 함수`는 함수의 인자로 전달되는 함수로 특정 작업이 완료된 후에 이 함수를 실행하도록 하는 것을 말합니다. 콜백 함수는 주로 비동기 처리를 위해 사용됩니다.

콜백 함수를 과도하게 중첩하여 사용하면 코드가 복잡해지고 이해하기 어려운 '콜백 헬'이 발생할 수 있습니다.

</br>

### 11. Promise

`Promise`는 자바스크립트에서 비동기 처리를 쉽고 효과적으로 할 수 있게 해주는 객체입니다. `Promise`는 '약속'을 의미하는데, 비동기 작업의 최종 완료 또는 실패를 나타내는 결과 값을 나타냅니다.

`Promise`는 `Pending`, `Fulfilled`, `Rejected` 세 가지 상태를 가집니다.

`Pending(대기)` : 비동기 처리 로직이 아직 완료되지 않은 상태입니다.

`Fulfilled(이행)` : 비동기 처리가 완료되어 Promise가 결과 값을 반환한 상태입니다

`Rejected(거부)` : 비동기 처리가 실패하거나 오류가 발생한 상태입니다.

`Promise`는 생성될 때 자동으로 `Pending` 상태가 되고, 비동기 작업이 성공하면 `Fulfilled` 상태가 되어 'then' 메소드를 통해 결과 값을 처리할 수 있습니다. 만약 비동기 작업이 실패하면 `Rejected` 상태가 되어 'catch' 메소드를 통해 오류를 처리할 수 있습니다.

또한 Promise는 Promise를 반환하기 때문에 `Promise chaining` 가능하며 이를 통해 비동기 처리를 순서대로 처리할 수 있습니다.

</br>

### 12. aysnc & await

`async` 와 `await`는 자바스크립트의 비동기 처리 패턴 중 하나로, `Promise`를 더 쉽고 간결하게 다룰 수 있게 해줍니다. `async`와 `await`를 사용하면 비동기 코드를 마치 동기 코드처럼 작성할 수 있습니다.

`async`키워드는 함수 앞에 사용되며, 이 함수는 항상 `Promise`를 반환합니다. 만약 `async` 함수가 값을 반환하면 이 값은 `Promise`로 감싸져 반환됩니다.

`await`키워드는 `async`함수 내부에서 사용되며, `Promise`의 완료를 기다립니다. `Promise`가 이행될 때까지 함수의 실행을 일시적으로 중단하고, `Promise`가 이행되면 결과 값을 반환합니다. 만약 `Promise`가 거부되면 예외가 발생합니다.

</br>

### 13. this

자바스크립트의 `this`는 현재 실행 중인 함수나 메소드가 속한 객체를 가르키는 특수한 키워드입니다. this는 함수 호출방식과 상황에 따라 동적으로 결정됩니다.

일반함수에서의 `this` 전역 객체를 가리킵니다. 브라우저 환경에서는 `window` 객체가 됩니다. 'strict mode'에서는 `undefined`가 됩니다.

객체의 메소드 내부에서 `this`를 사용하면, `this`는 해당 메소드를 호출한 객체를 가리킵니다.

생성자 함수에서 `this`를 사용하면, `this`는 새로 생성되는 객체를 가리킵니다.

이벤트 핸들러 내에서는 `this`는 이벤트를 발생시킨 DOM 요소를 가르킵니다.

화살표 함수에서 `this`는 함수가 생성될 때의 상위 스코프를의 `this`를 가르킵니다.

</br>

### 14. prototype

자바스크립트의 `프로토타입(Prototype)`은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 객체의 공통된 특성을 공유하는 메커니즘을 제공합니다.

자바스크립트는 프로토타입 기반 언어로, 클래스 기반 언어와는 다르게 '프로토타입'이라는 개념을 통해 객체의 상속과 메서드를 공유합니다. 이는 모든 객체가 다른 객체의 프로토타입으로부터 속성과 메서드를 상속받을 수 있다는 것을 의미합니다.

자바스크립트 어떤 객체의 속성이나 메서드에 접근하려 할 때, 해당 객체에 그 속성이나 메서드가 없다면 프로토타입 체인을 통해 그 객체의 프로토타입에서 그 속성이나 메서드를 찾습니다.

</br>

### 15. class

자바스크립트의 `class`는 ES6(ES2015)에서 도입된 문법으로, 프로토타입을 기반으로 만들어진 문법입니다. `class`는 기존의 프로토타입 기반 상속을 보다 명확하고 간결하게 표현할 수 있게 해줍니다.

`class`는 `constructor` 메소드를 포함할 수 있으며, 이 메소드는 클래스의 인스턴스를 생성하고 초기화하는데 사용됩니다.

</br>

### 16. 이벤트 위임

`이벤트 위임`의 기본 원리는 `이벤트 버블링(Event Bubbling)`에 기반합니다. 이벤트 버블링은 특정 요소에서 이벤트가 발생했을 때, 이 이벤트가 상위 요소로 전파되는 현상을 말합니다.

`이벤트 위임`을 사용하면, 하위 요소 각각에 이벤트 핸들러를 달지 않고 상위 요소에서 하나의 핸들러로 이벤트를 관리할 수 있습니다.

특히, `이벤트 위임`은 특히 동적으로 요소를 추가하거나 제거하는 경우, 이벤트 핸들러를 효율적으로 관리할 수 있게 해줍니다.

</br>

### 17. undefiend와 null의 차이점

`undefined`와 `null`은 자바스크립트에서 '값이 없음'을 나타내는 특별한 타입입니다.

`undefined`는 수가 선언되었지만 아직 값이 할당되지 않았을 때의 기본값입니다.

`null`은 의도적으로 '값이 없음'을 나타내고 싶을 때 사용됩니다. `null`은 개발자가 명시적으로 '아무런 값도 없음'을 표현하고자 할 때 사용하는 값입니다.

</br>

### 18. 이터러블과 이터레이터

`이터러블`은 순회 가능한 데이터 컬렉션(예: 배열, 문자열, Map, Set 등)을 나타냅니다. `이터러블 객체`는 `Symbol.iterator` 메소드를 가지며, 이 메소드는 `이터레이터`를 반환합니다.

`이터레이터`는 'next'라는 메소드를 가진 객체로, 이 메소드를 호출하면 컬렉션의 다음 요소를 반환합니다. 'next' 메소드는 'value'(현재 요소의 값)와 'done'(모든 요소를 순회했는지의 여부) 속성을 가진 객체를 반환합니다.

</br>

### 19. 제네레이터

제네레이터 함수는 `function*` 키워드를 사용하여 정의하며, `yield` 키워드를 사용하여 함수의 실행을 일시적으로 멈춥니다. 제네레이터 함수를 호출하면 제네레이터 객체가 반환되며, 이 객체는 이터레이터 프로토콜을 따릅니다.

제네레이터 객체는 제네레이터가 반환하는 객체로 이터러블이자 이터레이터 객체입니다.

제네레이터는 비동기 작업을 순차적으로 처리하거나, 사용자 정의 이터러블을 만드는 데 유용하게 사용될 수 있습니다.

</br>

### 20. 화살표 함수와 일반 함수 차이점

화살표 함수와 일반 함수의 주요 차이점은 `this`에 있습니다.

일반 함수의 this는 함수 호출방식에 따라 동적으로 바인딩됩니다.

화살표 함수는 상위 스코프의 `this`로 정적 바인딩됩니다.

이로 인해 화살표 함수에서는 `call`, `bind`, `apply` 메소드를 통해 this를 변경할 수 없습니다.

화살표 함수 this는 인스턴스 객체를 가르키지 않으므로 생성자 함수로 사용할 수 없습니다.

화살표 함수 this는 자신만의 `arguments` 객체를 가지지 않기 때문에 `arguments` 객체를 사용할 수 없습니다.

화살표 함수 문법적 오류가 발생하여 `yeild` 키워드에 사용할 수 없습니다.

</br>

### 21. <script> <script async> <script defer> 차이점

`<script>`, `<script async>`, `<script defer>`는 스크립트를 로드하고 실행하는 방식에 차이가 있습니다.

`<script>` 방식은 HTML 파싱을 중단하고 스크립트를 즉시 로드하고 실행합니다. 스크립트 로딩과 실행이 완료되면 HTML 파싱을 계속합니다. 이 방식은 스크립트 로딩이 페이지 렌더링을 차단하므로 사용자에게 페이지 로딩이 느리게 느껴질 수 있습니다.

`<script async>` 방식은 스크립트를 비동기로 로드합니다. 스크립트 로딩은 HTML 파싱과 동시에 병렬로 진행되며, 스크립트 로딩이 완료되면 HTML 파싱을 잠시 중단하고 스크립트를 실행합니다. 이 방식은 스크립트 로딩이 페이지 렌더링을 차단하지 않지만, 스크립트 실행 순서가 보장되지 않습니다.

`<script defet>` 방식은 스크립트를 비동기로 로드하되, 스크립트 실행은 HTML 파싱이 완료된 후에 진행됩니다. 이 방식은 스크립트 로딩이 페이지 렌더링을 차단하지 않으며, 스크립트 실행 순서가 보장됩니다.

