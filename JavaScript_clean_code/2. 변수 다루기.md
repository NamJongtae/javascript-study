# 2. 변수 다루기

### var 사용을 지양하기

- var는 **함수 스코프**를 가지며, 선언 후 **재할당**이 가능하다.
- 함수 외부에서 선언한 var 변수는 **전역변수**로 생성된다.
- var는 **중복 선언**이 가능하다.
- var는 **호이스팅(Hoisting)** 이 이루어지며, 선언 이전 참조할 수 있다.
- 이로 인해 예측하지 못한 결과를 초래할 수 있다.

### let

- **블록 스코프**를 가지며, **TDZ(Termporal Dead Zone)** 을 통해 안전한 코드를 작성할 수 있다.
- 선언 후 재할당이 가능하다.
- 중복 선언이 불가능하다.
- TDZ에 의해 선언 전 참조하는 것이 불가능하다.

### const

- **블록 스코프**를 가지며, **TDZ(Termporal Dead Zone)** 을 통해 안전한 코드를 작성할 수 있다.
- 선언과 동시에 할당을 해야한다.
- 선언 후 재할당이 불가능하다.
- 중복 선언이 불가능하다.
- TDZ에 의해 선언 전 참조하는 것이 불가능하다.

### 바뀌지 않는 값, 상수의 경우 const를 사용하기

- const는 재할당이 불가능 하기 때문에 개발자가 실수로 재할당을 통해 값을 변경하는 것을 막을 수 있다.
- 코드의 가독성과 유지 보수성을 높일 수 있다.

### 전역 공간 사용을 최소화 하기

- 전역공간은 어디서나 접근이 가능하여 런타임시 전역공간은 스코프가 분리되지 않아 전역 변수 오염의 위험이 있다.
- 전역공간에 선언된 변수, 함수는 프로그램이 종료되기 전까지 메모리 해제 되지 않아 메모리 낭비의 가능성이 존재한다.
- 최소화 방법
    - 전역변수 대신 지역변수 사용하기
    - window, global을 직접 조작 하지 않기
    - var 키워드 대신 const, let 키워드 사용하기
    - IIFE 즉시 실행 함수, Module, Closure로 스코프 나누기

### 임시 변수 제거하기

- 임시 변수 : 어느 특정 공간에서 전역 변수처럼 활용되는 변수
- 임시 변수의 위험성
    - 함수가 커지면 임시 변수는 코드 오염의 위험성이 존재한다.
    - 어떤 값이 되는지 파악이 어려워 디버깅의 어려움이 발생한다.
    - CRUD 추가적인 코드를 작성하고자 하는 유혹이 존재한다.
    - 명령형으로 가득한 로직이 될 수 있다.
- 해결책
    - 여러 함수로 나누기
    - return으로 바로 반환하기
    - 선언형 프로그래밍하기
    - 고차함수 사용하기 (map, filter, reducer)

### 호이스팅 주의하기

- 호이스팅(Hoisting) : JavaScript에서 변수와 함수 선언이 코드의 최상단으로 끌어올려지는 현상을 의미한다.
- 함수는 호이스팅이 이루어진다.
- var 키워드를 사용하면 호이스팅이 이루어진다.
- 호이스팅에 의해 예측하지 못한 결과를 가져올 수 있다.
- 해결책
    - 함수 생성시 함수 표현식 사용
    - var 키워드 사용 지양하기